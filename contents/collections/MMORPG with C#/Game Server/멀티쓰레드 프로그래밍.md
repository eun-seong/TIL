# ë©€í‹°ì“°ë ˆë“œ ê°œë¡ 

# ì“°ë ˆë“œ ìƒì„±

# ì»´íŒŒì¼ëŸ¬ ìµœì í™”
devëª¨ë“œì—ì„œ ì˜ ë˜ë˜ê²Œ, release ëª¨ë“œì—ì„  ì‘ë™ì•ˆí•˜ëŠ” ê²Œ ìˆë‹¤.
ì»´íŒŒì¼ëŸ¬ê°€ ìµœì í™”ë¥¼ í–ˆê¸° ë•Œë¬¸ã…‡.

```c#
bool _stop = false;

// ìŠ¤ë ˆë“œ A
while(_stop == false) {
	// ë­”ê°€ ì—„ì²­ë‚œ ì¼
	// í•˜ì§€ë§Œ _stop ë³€ìˆ˜ë¥¼ ë³€ê²½í•˜ì§€ëŠ” ì•ŠìŒ
}


// ìŠ¤ë ˆë“œ B
_stop = true;
```
ì›ë˜ ì´ëŸ° ì½”ë“œì˜€ëŠ”ë°, ìŠ¤ë ˆë“œ Aì—ì„œ ë™ì‘í•˜ëŠ” ì½”ë“œë¥¼
```c#
if(_stop) {
	while(true) {
		// ë­”ê°€ ì—„ì²­ë‚œ ì¼
	}
}
```
ì´ë ‡ê²Œ ìµœì í™”í•´ë²„ë¦¼.
`_stop` ë³€ìˆ˜ë¥¼ `while`ì•ˆì—ì„œ ë³€ê²½í•˜ì§€ ì•Šìœ¼ë‹ˆê¹Œ, ifë¥¼ ë¨¼ì € ë‘ê³  ë¬´í•œ ë°˜ë³µí•´ë²„ë¦¬ëŠ” ê±°ì„.

ì´ ê²½ìš° `volatile` í‚¤ì›Œë“œë¥¼ ë¶™ì´ëŠ” ê²ƒì´ í•œ ë°©ë²•ì´ ë  ìˆ˜ ìˆë‹¤(ìµœì„ ì˜ ë°©ë²•ì€ ì•„ë‹˜)
```c#
volatile static bool _stop = false;
```


# ìºì‹œ ì´ë¡ 
CPUëŠ” ì½”ì–´ ê°ìë§ˆë‹¤ ìºì‹œë¥¼ ê°€ì§€ê³  ìˆë‹¤.
í•˜ì§€ë§Œ RAMì€ í•˜ë‚˜ì´ë‹¤.

ë³€ê²½ëœ ë‚´ì—­ì„ ìºì‹œì—ì„œ ëª¨ì•„ë†“ê³  ìˆë‹¤ê°€, í•œ ë²ˆì— RAMìœ¼ë¡œ ê°€ì ¸ë‹¤ ë†“ëŠ”ë‹¤.

### ìºì‹œ ì² í•™
1. Temporal localty
   ê°€ì¥ ìµœì‹ ì— ì‚¬ìš©ë˜ì—ˆë˜ ë©”ëª¨ë¦¬ ê°’ë“¤ì´ ë” ìì£¼ ì‚¬ìš©ë  ê²ƒì´ë‹¤.
2. spacial localty
   ê³µê°„ì ìœ¼ë¡œ ë°©ê¸ˆ ì‚¬ìš©ë˜ì—ˆë˜ ë©”ëª¨ë¦¬ ê°’ì˜ ê·¼ì²˜ì— ê°’ë“¤ì´ ë” ìì£¼ ì‚¬ìš©ë  ê²ƒì´ë‹¤.

>í…ŒìŠ¤íŠ¸ í•´ë³´ê¸°

```c#
using System;
using System.Threading;
using System.Threading.Tasks;

namespace ServerCore
{
    class Program
    {
        static void Main(string[] args)
        {
            int[,] arr = new int[10000, 10000];
            {
                long now = DateTime.Now.Ticks;
                for (int y = 0; y < 10000; y++)
                {
                    for (int x = 0; x < 10000; x++)
                    {
                        arr[y, x] = 1;
                    }
                }
                long end = DateTime.Now.Ticks;
                Console.WriteLine($"(y, x) ìˆœì„œ ê±¸ë¦° ì‹œê°„ {end - now}");
            }


            {
                long now = DateTime.Now.Ticks;
                for (int y = 0; y < 10000; y++)
                {
                    for (int x = 0; x < 10000; x++)
                    {
                        arr[x, y] = 1;
                    }
                }
                long end = DateTime.Now.Ticks;
                Console.WriteLine($"(y, x) ìˆœì„œ ê±¸ë¦° ì‹œê°„ {end - now}");
            }
        }
    }
}

```

ì•„ë«ì¤„ì˜ `arr[x, y]`ë¡œ ì ‘ê·¼í•œ ê²ƒì´ ë” ì˜¤ë˜ ê±¸ë¦°ë‹¤.
ì™œ? -> "ì—´" ì¢Œí‘œë¥¼ ë¨¼ì € ì ‘ê·¼í•˜ê¸° ë•Œë¬¸..
"í–‰" ì¢Œí‘œë¥¼ ë¨¼ì € ì ‘ê·¼í•˜ë©´ ë©”ëª¨ë¦¬ ì°¨ë¡€ëŒ€ë¡œ ì ‘ê·¼í•˜ëŠ”ë°, "ì—´" ì¢Œí‘œë¥¼ ë¨¼ì € ì ‘ê·¼í•˜ë©´ ë„ì—„ë„ì—„ ì ‘ê·¼í•˜ê¸° ë•Œë¬¸ì— ìºì‹œì— ì—†ì„ í™•ë¥ ì´ ë” ë§ì•„ì§„ë‹¤.


# ë©”ëª¨ë¦¬ ë°°ë¦¬ì–´
```c#
using System;
using System.Threading;
using System.Threading.Tasks;

namespace ServerCore
{
    class Program
    {
        static int x = 0;
        static int y = 0;
        static int r1 = 0;
        static int r2 = 0;

        static void Thread_1()
        {
            x = 1;  // Store x
            Thread.MemoryBarrier();
            r1 = y; // Load y
        }

        static void Thread_2()
        {
            y = 1;  // Store y
            r2 = x; // Load x
        }

        static void Main(string[] args)
        {
            int count = 0;

            while (true)
            {
                count++;
                x = y = r1 = r2 = 0;

                Task task1 = new Task(Thread_1);
                Task task2 = new Task(Thread_2);

                task1.Start();
                task2.Start();

                Task.WaitAll(task1, task2);

                if (r1 == 0 && r2 == 0)
                {
                    break;
                }
            }
            Console.WriteLine($"{count} ë¹ ì ¸ë‚˜ì˜´");
        }
    }
}
```

ë†€ëê²Œë„ ìœ„ ì½”ë“œë¥¼ ì‹¤í–‰í•˜ë©´ `r1`ê³¼ `r2`ê°€ ëª¨ë‘ 0ì¸ ìˆœê°„ì´ ì¡´ì¬í•˜ê²Œ ëœë‹¤. 
ì–´ë–»ê²Œ???!!?!?!!

ì—°ì†ëœ ëª…ë ¹ì–´ê°€ ì—°ê´€ì´ ì—†ë‹¤ê³  íŒë‹¨í•˜ë©´ í•˜ë“œì›¨ì–´ê°€ ì½”ë“œì˜ ìˆœì„œë¥¼ ë°”ê¾¸ê¸°ë„ í•œë‹¤.
ì˜ˆë¥¼ ë“¤ì–´,
```c#
static void Thread_1()
{
	x = 1;
	r1 = y;
}
```
ì´ ë©”ì†Œë“œì˜ ê²½ìš° `x=1`ê³¼ `r1=y`ì˜ ì½”ë“œê°€ ì„œë¡œ ì—°ê´€ì´ ì—†ê¸° ë•Œë¬¸ì— 
```c#
static void Thread_1()
{
	r1 = y;
	x = 1;
}
```
ì´ë ‡ê²Œ ì‹¤í–‰ë˜ëŠ” ê²ƒì²˜ëŸ¼ ë³€ê²½ë˜ê¸°ë„ í•œë‹¤.
ì´ê±¸ í•˜ë“œì›¨ì–´ê°€ ìµœì í™”í•´ì¤Œ...

ì‹±ê¸€ìŠ¤ë ˆë“œì—ì„œëŠ” ê·¸ë ‡ê²Œ í¬ê²Œ ìƒê´€ì´ ì—†ë‹¤. ë§ì§€?!
í•˜ì§€ë‚˜ ë©€í‹°ìŠ¤ë ˆë“œì—ì„œëŠ” ìƒê´€ì´ ìˆë‹¤.
ì´ê±¸ ì—†ì• ë ¤ë©´ ì–´ë–»ê²Œ í•´ì•¼ í• ê¹Œ?

ì–´ì…ˆë¸”ë¦¬ì–´ : `MFENCE`
C# : `Thread.MemoryBarier()`

```c#
static void Thread_1()
{
	x = 1;
	Thread.MemoryBarrier();
	r1 = y;
}
```

## íš¨ê³¼A) ì½”ë“œ ì¬ë°°ì¹˜ ì–µì œ
### 1. Full Memory Barrier
Store / Load ë‘˜ ë‹¤ ë§‰ëŠ”ë‹¤.

### 2. Store Memory Barrier
Storeë§Œ ë§‰ëŠ”ë‹¤.

### 3. Load Memory Barrier
Loadë§Œ ë§‰ëŠ”ë‹¤.



## íš¨ê³¼B) ê°€ì‹œì„±
`Thread.MemoryBarrier()`ê°€ ìˆìœ¼ë©´ ì½”ë“œì˜ ê°€ì‹œì„±ì´ ë” ì¢‹ì•„ì§„ë‹¤.
ì´ê±¸ ì»¤ë°‹ì´ë¼ê³  ìƒê°í•˜ë©´,
Storeë¥¼ í•œ ë…€ì„ì€ ì»¤ë°‹ì„ í†µí•´ ë™ê¸°í™”ë¥¼ í•˜ê³ ,
Loadë¥¼ í•œ ë…€ì„ì€ ì»¤ë°‹ëœ ê²ƒì„ ë¨¼ì € ê°€ì ¸ì˜¤ê³  ì‘ì—…ì„ ìˆ˜í–‰í•œë‹¤.

ê·¸ë ‡ê¸° ë•Œë¬¸ì— Storeë¥¼ í•˜ê³  ë‚˜ì„œ ì»¤ë°‹ì„ í•˜ê³ , Loadí•˜ê¸° ì „ì—ë„ ì»¤ë°‹ì„ í•œ ë²ˆ í•´ì¤˜ì•¼ "ë™ê¸°í™”"ê°€ ì •ìƒì ìœ¼ë¡œ ì‘ë™í•˜ê¸° ë•Œë¬¸ì—
ì£¼ì˜í•´ì•¼ í•œë‹¤.
```c#
int _answer;
bool _complete;

void A() {
	_answer = 123;
	Thread.MemoryBarrier();
	_complete = true;
	Thread.MemoryBarrier(); // ì£¼ì˜
}

void B() {
	Thraed.MemoryBarrier(); // ì£¼ì˜
	if(_complete) {
		Thread.MemoryBarrier();
		Console.WriteLine(_answer)
	}
}
```


# Interlocked

```c#
number++;
```
ì´ ëª…ë ¹ì–´ëŠ”

```c#
tmp = numberì˜ ë©”ëª¨ë¦¬ì— ì €ì¥ëœ ê°’;
tmpë¥¼ 1ì¦ê°€
numberì˜ ë©”ëª¨ë¦¬ = tmp;
```
ì´ë ‡ê²Œ 3ê°€ì§€ì˜ ì–´ì…ˆë¸”ë¦¬ë¡œ ì´ë£¨ì–´ì ¸ìˆë‹¤.
ê·¸ë˜ì„œ ì´ ëª…ë ¹ì–´ê°€ ì´ë£¨ì–´ì§€ê³  "ë™ì•ˆì—" ì»¨í…ìŠ¤íŠ¸ ìŠ¤ìœ„ì¹­ì´ ë°œìƒí•˜ê³  ë‹¤ë¥¸ ìŠ¤ë ˆë“œê°€ `number`ë¥¼ ìˆ˜ì •í•˜ê²Œ ëœë‹¤ë©´, 
ì›í•˜ëŠ” ê²°ê³¼ê°€ ë‚˜ì˜¤ì§€ ì•Šì„ ìˆ˜ ìˆë‹¤.

ì´ ê²½ìš° `Interlocked`ë¥¼ ì‚¬ìš©í•˜ë©´
```c#
int afterValue = Interlocked.Increment(ref number); // atomicí•œ number++
```

ì›ìì ìœ¼ë¡œ(atomic) `number++`ë¥¼ í•  ìˆ˜ ìˆë‹¤.
(ë¬¼ë¡  ì„±ëŠ¥ì ìœ¼ë¡œ ë§ì´ ë–¨ì–´ì§€ê²Œ ëœë‹¤.)

atomicí•˜ê¸° ë•Œë¬¸ì— ë¬´ì¡°ê±´ ëª¨ë‘ ì‹¤í–‰ë˜ê±°ë‚˜, ì•„ì˜ˆ ì‹¤í–‰ë˜ì§€ ì•ŠëŠ”ë‹¤.
ì•½ê°„ transectionì´ë‘ ë¹„ìŠ·í•œ ê²ƒ ê°™ê¸°ë‘?




# Lock
ë©€í‹°ìŠ¤ë ˆë“œì—ì„œ ì§„ì§œ ë¬¸ì œê°€ ë˜ëŠ” ë¶€ë¶„ì€ ê°’ì„ "ì“¸" ë•Œë‹¤.
ì½ê¸°ë§Œ í•˜ë©´ ìƒê´€ì—†ë‹¤..
ê·¸ëŸ°ë° ì–´ë–¤ ìŠ¤ë ˆë“œê°€ ê·¸ ë³€ìˆ˜ì— ì“°ê¸° ì‹œì‘í•˜ë©´ ë¬¸ì œê°€ ì‹œì‘ëœë‹¤.

## `Monitor`

```c#
static object _obj = new object();

Monitor.Enter(_obj); // ì ê·¸ê¸°
number++;
Monitor.Exit(_obj);  // ì ê¸ˆ í•´ì œ
```

ìƒí˜¸ë°°ì œ(Mutual Exclusive)í•  ìˆ˜ ìˆë‹¤.
c++ì—ì„œ `CriticalSection`ê³¼ `std::mutex`ì™€ ìœ ì‚¬í•˜ë‹¤.


ì—¬ê¸°ì„œë„ ë§ˆì°¬ê°€ì§€ë¡œ ì„ê³„ ì˜ì—­ì„ ì„ ì í•´ë†“ê³  í•´ì œí•˜ì§€ ì•Šìœ¼ë©´ ë¬¸ì œê°€ ë°œìƒí•œë‹¤.
ê·¸ë˜ì„œ ì—¬ê¸°ì„œë„ ë§ˆì°¬ê°€ì§€ë¡œ ë˜ c++ì˜ `load_guard`ê°™ì€ ê²ƒì´ ì¡´ì¬í•œë‹¤. ë°”ë¡œ

## `lock`
```c#
lock(_obj) {
	number++;
}
// ëë‚˜ë©´ ì•Œì•„ì„œ í•´ì œí•¨
```



# DeadLock
ë‘ ìŠ¤ë ˆë“œê°€ ì„œë¡œ ë‹¤ë¥¸ lockì„ ê°€ì§€ê³  ìƒëŒ€ë°©ì˜ lockì„ í•¨ê»˜ ê¸°ë‹¤ë¦¬ëŠ” ìƒí™©

ê°œë°œ ë‹¨ê³„ì—ì„œ ì˜ ì¼ì–´ë‚˜ì§€ ì•Šë‹¤ê°€, ìœ ì €ë“¤ì´ ëª°ë¦´ ë•Œ ë‚˜íƒ€ë‚  ë•Œê°€ ë§ë‹¤.. ë”ì°..
í•˜ì§€ë§Œ ë°ë“œë½ì€ ë°œê²¬í•˜ê¸°ê¹Œì§€ê°€ ì–´ë ¤ìš´ ê±°ê³  ë°œìƒí•˜ê³  ë‚˜ì„œ ìˆ˜ì •í•˜ëŠ” ê±´ ì‰¬ìš¸ ìˆ˜ë„?



# Lock êµ¬í˜„ 

## 1. Spin Lock ğŸ”¥ğŸ”¥ğŸ”¥
>ê·¸ëƒ¥ ë¬´ì‘ì • ê¸°ë‹¤ë¦°ë‹¤(ì¡´ë²„ ë©”íƒ€)

ë°”ë¡œ ì•ˆë‚˜ì˜¬ ê²½ìš° ì‹œê°„ ë‚­ë¹„ê°€ í¼
í•˜ì§€ë§Œ ê°€ì¥ ë‹¨ìˆœí•˜ê³  ì‰¬ìš´ ë°©ë²•


ì´ ì½”ë“œì˜ ë¬¸ì œì ì€?
```c#
using System;
using System.Threading;
using System.Threading.Tasks;

namespace ServerCore
{
    class SpinLock
    {
        volatile bool _locked = false;

        public void Acquire()
        {
            while (_locked)
            {
                // ì ê¸ˆì´ í’€ë¦¬ê¸¸ ê¸°ë‹¤ë¦°ë‹¤
            }

            _locked = true;
            // íšë“í•˜ê³  ì‘ì—…í•˜ê¸°
        }

        public void Release()
        {
            _locked = false;
        }
    }

    class Program
    {

        static int _num = 0;
        static SpinLock _lock = new SpinLock();

        static void Thread_1()
        {
            for (int i = 0; i < 100000; i++)
            {
                _lock.Acquire();
                _num++;
                _lock.Release();
            }
        }

        static void Thread_2()
        {
            for (int i = 0; i < 100000; i++)
            {
                _lock.Acquire();
                _num--;
                _lock.Release();
            }
        }

        static void Main(string[] args)
        {
            Task t1 = new Task(Thread_1);
            Task t2 = new Task(Thread_2);

            t1.Start();
            t2.Start();

            Task.WaitAll(t1, t2);

            Console.WriteLine(_num);
        }
    }
}
```

ë°”ë¡œë°”ë¡œ~!~!~!~!
`SpinkLock.acquire()` ì•ˆì—ì„œ whileê³¼ lockì„ ì„ ì í•˜ëŠ” êµ¬ë¬¸ì´ atomicí•˜ì§€ ì•Šê¸° ë•Œë¬¸!
ê·¸ë˜ì„œ ìŠ¤ë ˆë“œ ì—¬ëŸ¬ ê°œê°€ ë™ì‹œì— `acquire()`ë¥¼ í•˜ê²Œ ë˜ë©´ ë‘˜ ë‹¤ lockì„ ì„ ì í•˜ëŠ” ì¼ì´ ë°œìƒí•œë‹¤.

ê·¸ëŸ¼ ì–´ë–»ê²Œ í•˜ë‚˜? -> `Interlocked`ì„ ì´ìš©í•´ë³´ì
```c#
    class SpinLock
    {
        volatile int _locked = 0;

        public void Acquire()
        {
            while(true)
            {
                int original = Interlocked.CompareExchange(ref _locked, 1, 0);
                if (original == 0)
                {
                    // ì„ ì ì„ ì™„ë£Œí–ˆë‹¤!
                    break;
                }
                else if (original == 1)
                {
                    // í•œ ë°œ ëŠ¦ìŒ..
                }
            }
        }

        public void Release()
        {
            _locked = 0;
        }
    }
```
`Interlocked.CompareExchange` ëŠ” ì´ì „ì˜ ê°’ì„ ë‚´ë±‰ëŠ”ë‹¤.
ê·¸ë˜ì„œ ì´ì „ì˜ ê°’ìœ¼ë¡œ ì´ë¯¸ ì„ ì ì´ ë˜ì—ˆì—ˆëŠ”ì§€ ì•„ë‹Œì§€ í™•ì¸í•  ìˆ˜ ìˆë‹¤.

ê³µìœ  ë³€ìˆ˜ë¥¼ ë‹¤ë£° ë•ŒëŠ” í•­ìƒ ì¡°ì‹¬í•˜ì.
ì´ ë³€ìˆ˜ë¥¼ ì½ê³  ì“°ëŠ” ê²ƒì´ "ë‚˜ëˆ ì§„" ë¶€ë¶„ì€ ì—†ëŠ”ì§€ í•­ìƒ ì²´í¬í•´ì•¼ í•œë‹¤!

SpinLock ìš”ì•½ : ëº‘ëº‘ì´ë¥¼ ëŒë©´ì„œ **CompareAndSwap(CAS)**ì„ í•˜ëŠ” ë…€ì„
``


### 2. ì¼ë‹¨ ìë¦¬ë¡œ, ë‚˜ì¤‘ì— ë‹¤ì‹œ(ëœë¤ ë©”íƒ€)
ìê¸° ì†Œìœ ê¶Œì„ í¬ê¸°í•˜ê³  ë‚˜ì¤‘ì— ë‹¤ì‹œ ì™€ë´„
ì‹œê°„ì„ íš¨ìœ¨ì ìœ¼ë¡œ ì“¸ ìˆ˜ìˆê¸´í•œë°, ë‚˜ì¤‘ì— ì™”ì„ ë•Œ ì´ë¯¸ ë‹¤ë¥¸ ì• ê°€ ì ìœ í•˜ê³  ìˆì–´ì„œ ë˜ ê¸°ë‹¤ë ¤ì•¼ í•  ìˆ˜ë„ ìˆìŒ

```c#
        public void Acquire()
        {
            while(true)
            {
                int original = Interlocked.CompareExchange(ref _locked, 1, 0);
                if (original == 0)
                {
                    // ì„ ì ì„ ì™„ë£Œí–ˆë‹¤!
                    break;
                }
                else if (original == 1)
                {
                    // í•œ ë°œ ëŠ¦ìŒ..
		            
		            /**************************/
		            // ì—¬ê¸°ì„œ ì–´ë–»ê²Œ í•  ê±´ì§€ê°€ ê´€ê±´
		            // ì•„ë¬´ê²ƒë„ í•˜ì§€ ì•Šê³  ë‹¤ì‹œ whileë¡œ ê°€ë©´ spinlock
		            // í˜¹ì€ CPU ì„ ì ì„ ì–‘ë³´í•˜ë©´ ëœë¤
                }
            }
        }
```


### ìŠ¤ë ˆë“œê°€ ì–‘ë³´í•˜ëŠ” 3ê°€ì§€ ìœ í˜•
1. `Thread.Sleep(1)`
ë¬´ì¡°ê±´ íœ´ì‹
ë¬´ì¡°ê±´ 1ms ì •ë„ ì‰´ê±°ì—ìš”.
ê·¸ëŸ°ë° ë”± 1msë§Œ ì‰¬ëŠ” ê±´ ì•„ë‹ˆê³ , OSê°€ 1msì— ì–´ëŠì •ë„ ë§ì¶°ì„œ ë‹¤ì‹œ ì‹¤í–‰ì‹œì¼œì¤Œ
ì§„ì§œ ë”± 1ms ì‰´ ìˆ˜ ìˆì„ì§€ëŠ” ë³´ì¥í•  ìˆ˜ ì—†ë‹¤

2. `Thread.Sleep(0)`
ì¡°ê±´ë¶€ ì–‘ë³´ : ë‚´ ìš°ì„ ìˆ˜ìœ„ë³´ë‹¤ **ê°™ê±°ë‚˜ ë†’ì€** ìŠ¤ë ˆë“œì—ê²Œë§Œ ì–‘ë³´. ì—†ìœ¼ë©´ ë‹¤ì‹œ ë‚´ê°€ ëƒ ëƒ 
ìì£¼ ì‹¤í–‰í•  ìˆ˜ëŠ” ìˆê² ì§€ë§Œ, ë„ˆë¬´ ë‚˜ë§Œ ì„ ì í•˜ê³  ìˆëŠ” ë¬¸ì œê°€ ë°œìƒí•  ìˆ˜ë„ ìˆë‹¤.

3. `Thread.Yield()`
ê´€ëŒ€í•œ ì–‘ë³´ : ëŒ€ê¸°í•˜ê³  ìˆëŠ” ìŠ¤ë ˆë“œê°€ ìˆë‹¤ë©´ ì–‘ë³´. ì—†ìœ¼ë©´ ë‹¤ì‹œ ë‚´ê°€ ëƒ ëƒ 
ë‚˜í•œí…ŒëŠ”  ì†Œìœ ê¶Œì´ ì•ˆì˜¬ ìˆ˜ë„..?


### ì»¨í…ìŠ¤íŠ¸ ìŠ¤ìœ„ì¹­

ì»¨í…ìŠ¤íŠ¸ ìŠ¤ìœ„ì¹­ì´ ë°œìƒí•˜ë©´,
ë ˆì§€ìŠ¤í„°ì— ìˆëŠ” ë°ì´í„°ë¥¼ ë©”ëª¨ë¦¬ì— ì˜¬ë ¤ë†”ì•¼ í•œë‹¤.
-> ì´ ì‘ì—…ì´ ì½”ìŠ¤íŠ¸ê°€ í¬ë‹¤.
ê·¸ë˜ì„œ ì»¨í…ŒìŠ¤íŠ¸ ìŠ¤ìœ„ì¹­í•˜ì§€ ì•Šê³  ì–´ì©Œë©´ ì–´ë– í•œ ìƒí™©ì—ëŠ” spin lockì„ í•˜ëŠ” ê²Œ ë” íš¨ìœ¨ì ì¼ ìˆ˜ë„ ìˆë‹¤.





### 3. ë‚œ ì†Œì¤‘í•˜ë‹ˆ ì§ì›í•œí…Œ ë¶€íƒ(ê°‘ì§ˆ ë©”íƒ€)
ì»¤ë„í•œí…Œ ë¹„ì›Œì§€ë©´ ì•Œë ¤ë‹¬ë¼ê³  í•¨

Event ëŠ” ì»¤ë„ê³¼ ì†Œí†µí•  ìˆ˜ ìˆëŠ” í•˜ë‚˜ì˜ ì±„ë„ì¼ ë¿
ë½ì— ì¢…ì†ì ì¸ ê°œë…ì€ ì•„ë‹ˆë‹¤.


### `AutoResetEvent`
ìë™ìœ¼ë¡œ ë¬¸ì„ ì—´ê³  ë‹«ì•„ì¤€ë‹¤.
**ì»¤ë„**ê¹Œì§€ ì™”ë‹¤ê°”ë‹¤ í•˜ê¸° ë•Œë¬¸ì— ê°œã…ã…ã…ã…ã…ëŠë ¤ì§

```c#
    class Lock
    {
        AutoResetEvent _available = new AutoResetEvent(true);

        public void Acquire()
        {
            _available.WaitOne(); // ì…ì¥ ì‹œë„
            // ì…ì¥ì´ ì„±ê³µí•˜ë©´ ìë™ìœ¼ë¡œ ë‹«ì•„ì¤Œ(ì„ ì  ì™„ë£Œ)
        }

        public void Release()
        {
            _available.Set();
        }
    }
```


### `ManualResetEvent`
**ì»¤ë„**ê¹Œì§€ ì™”ë‹¤ê°”ë‹¤ í•˜ê¸° ë•Œë¬¸ì— ê°œã…ã…ã…ã…ã…ëŠë ¤ì§
```c#
    class Lock
    {
        ManualResetEvent _available = new ManualResetEvent(true);

        public void Acquire()
        {
            _available.WaitOne(); // ì…ì¥ ì‹œë„
            _available.Reset();   // ë¬¸ ë‹«ìŒ
        }

        public void Release()
        {
            _available.Set();
        }
    }
```

ì´ë ‡ê²Œ í•˜ëŠ” ê±´ ë¬¸ì œê°€ ìˆë‹¤.
ì…ì¥ ì‹œë„í•˜ê³  ë¬¸ ë‹«ëŠ”ê²Œ atomicí•˜ì§€ ì•Šë‹¤!!!!


ê·¸ëŸ¼ ì´ê±¸ ì–¸ì œ ì‚¬ìš©í•˜ë‚˜? => ê¼­ í•˜ë‚˜ì”© ì…ì¥ ì‹œí‚¬ í•„ìš”ê°€ ì—†ì„ ê²½ìš°
ì˜ˆë¥¼ ë“¤ì–´ì„œ ì—„ì²­ë‚˜ê²Œ ê¸´ ì‘ì—…ì„ ì—¬ëŸ¬ ìŠ¤ë ˆë“œê°€ ê¸°ë‹¤ë¦¬ë‹¤ê°€, ì—„ì²­ë‚˜ê²Œ ê¸´ ì‘ì—…ì´ ëë‚˜ë©´ í•œ ë²ˆì— ë‹¤ `_available.Set()`í•˜ë©´ ë¨


### `Mutex`
mutex ì‚¬ìš©í•  ìˆ˜ë„ ìˆìŒ
**ì»¤ë„**ê¹Œì§€ ì™”ë‹¤ê°”ë‹¤ í•˜ê¸° ë•Œë¬¸ì— ì¢€ ëŠë ¤ì§

```c#
        static Mutex _lock = new Mutex();

        static void Thread_1()
        {
            for (int i = 0; i < 100000; i++)
            {
                _lock.WaitOne();
                _num++;
                _lock.ReleaseMutex();
            }
        }

        static void Thread_2()
        {
            for (int i = 0; i < 100000; i++)
            {
                _lock.WaitOne();
                _num--;
                _lock.ReleaseMutex();
            }
        }
```



# ReaderWriterLock
ì½ê¸°ëŠ” ë§ì´ ê°€ëŠ¥í•˜ê³ , ì“°ê¸°ë§Œ lockì„ ê±¸ì–´ì•¼ í•  ê²½ìš°

ì˜ˆë¥¼ ë“¤ì–´, ìš´ì˜ìƒ ì•„ì£¼ ê°€ë” ì˜ˆì™¸ì ìœ¼ë¡œ ë³´ìƒì„ ì£¼ì–´ì•¼í•  ë•Œ
```c#
        static ReaderWriterLockSlim _lock = new ReaderWriterLockSlim();

        static Reward GetRewardById(int id)
        {
            _lock.EnterReadLock();
            // ëˆ„êµ¬ë‚˜ ë“¤ì–´ì™€ì„œ ì½ì„ ìˆ˜ ìˆìŒ
            _lock.ExitReadLock();

            return null;
        }

        static void AddReward(Reward reward)
        {
            _lock.EnterWriteLock();
            // ì“°ê¸° lockì´ ê±¸ë¦¬ë©´ ë‹¤ë¥¸ ìŠ¤ë ˆë“œì—ì„œ ì½ê¸°ë„ ë§‰í˜
            _lock.ExitWriteLock();
        }
```

### êµ¬í˜„í•´ë³´ê¸°

```c#
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace ServerCore
{
    // ì¬ê·€ì  ë½ì„ í—ˆìš©í• ì§€
    // ìŠ¤í•€ë½ ì •ì±… (5000ë²ˆ -> yield)
    class Lock
    {
        const int EMPTY_FLAG = 0x00000000;
        const int WRITE_MASK = 0x7FFF0000;
        const int READ_MASK = 0x0000FFFF;
        const int MAX_SPIN_COUNT = 5000;

        // [Unused(1)] [WriteThreadId(15)] [ReadCount(16)]
        int _flag = EMPTY_FLAG;
        int _writeCount = 0;

        public void WriteLock()
        {
            // ë™ì¼ ìŠ¤ë ˆë“œê°€ WriteLockì„ ì´ë¯¸ íšë“í•˜ê³  ìˆëŠ”ì§€ í™•ì¸
            int lockThreadId = (_flag & WRITE_MASK) >> 16;
            if (Thread.CurrentThread.ManagedThreadId == lockThreadId)
            {
                _writeCount++;
                return;
            }

            // ì•„ë¬´ë„ WriteLock or ReadLockì„ íšë“í•˜ê³  ìˆì§€ ì•Šì„ ë•Œ, ê²½í•©í•´ì„œ ì†Œìœ ê¶Œì„ ì–»ëŠ”ë‹¤.
            int desired = (Thread.CurrentThread.ManagedThreadId << 16) & WRITE_MASK;
            while (true)
            {
                for (int i = 0; i < MAX_SPIN_COUNT; i++)
                {
                    if (Interlocked.CompareExchange(ref _flag, desired, EMPTY_FLAG) == EMPTY_FLAG)
                    {
                        _writeCount = 1;
                        return;
                    }
                }
                Thread.Yield();
            }
        }

        public void WriteUnlock()
        {
            int lockCount = --_writeCount;
            if (lockCount == 0)
                Interlocked.Exchange(ref _flag, EMPTY_FLAG);
        }

        public void ReadLock()
        {
            // ë™ì¼ ìŠ¤ë ˆë“œê°€ WriteLockì„ ì´ë¯¸ íšë“í•˜ê³  ìˆëŠ”ì§€ í™•ì¸
            int lockThreadId = (_flag & WRITE_MASK) >> 16;
            if (Thread.CurrentThread.ManagedThreadId == lockThreadId)
            {
                Interlocked.Increment(ref _flag);
                return;
            }

            // ì•„ë¬´ë„ WriteLockë¥¼ íšë“í•˜ê³  ìˆì§€ ì•Šìœ¼ë©´, ReadCountë¥¼ 1ëŠ˜ë¦°ë‹¤
            while (true)
            {
                for (int i = 0; i < MAX_SPIN_COUNT; i++)
                {
                    int expected = (_flag & READ_MASK);
                    if (Interlocked.CompareExchange(ref _flag, expected + 1, expected) == expected)
                    {
                        return;
                    }
                }
                Thread.Yield();
            }
        }

        public void ReadUnlock()
        {
            Interlocked.Decrement(ref _flag);
        }
    }
}
```



# Thread Local Storage(TLS)

```c#
static ThreadLocal<string> ThreadName = new ThreadLocal<string>();
```

ìŠ¤ë ˆë“œë§ˆë‹¤ ê°ê° stackì„ ê°€ì§ˆ ìˆ˜ ìˆë‹¤.

