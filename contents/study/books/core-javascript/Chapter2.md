---
title: 'Ch2. 실행 컨텍스트'
---


# 02 실행 컨텍스트

실행 컨텍스트(Execution Context)는 **실행할 코드에 제공할 환경 정보들을 모아놓은 객체**로, 자바스크립트의 동적 언어로서의 성격을 가장 잘 파악할 수 있는 개념이다. 자바스크립트에서 가장 중요한 핵심 개념 중 하나이다.

## 실행 컨텍스트란?

<u>동일한 환경</u>에 있는 코드들을 실행할 때 필요한 **환경 정보**들을 모아 컨텍스트를 구성하고, 이를 **콜 스택에 쌓아**올렸다가, <u>가장 위에 쌓여 있는 컨텍스트와 관련 있는 코드들을 실행</u>하는 식으로 전체 코드의 환경과 순서를 보장한다.
'동일한 환경'이란 하나의 실행 컨텍스트를 구성할 수 있는 방법으로 전역공간, `eval()` 함수, 함수 등이 있다. 여기서 전역 공간(자동으로 생성)과 `eval()` 함수를 제외하면 실행 컨텍스트를 구성하는 방법은 <u>함수를 실행하는 방법밖에 없다.</u>

1. 자바스크립트 코드를 실행하는 순간 전역 컨텍스트가 콜 스택이 담긴다.
2. 함수를 호출하면 해당 자바스크립트 엔진은 해당 함수에 대한 환경 정보를 수집해서 해당 함수 실행 컨텍스트를 생성한 후 콜 스택에 담는다.
3. 콜 스택 맨 위에 함수의 실행 컨텍스트가 담겼으므로 전역 컨텍스트와 관련된 코드의 실행을 일시중단한다.
4. 해당 함수의 실행 컨텍스트와 관련된 코드(함수 내부의 코드)를 순차적으로 실행한다.
5. 함수 안의 중첩된 함수 호출이 있을 경우 2-3번을 반복한다.
6. 가장 위에 있는 함수가 종료되면 그 함수의 실행 컨텍스트가 콜 스택에서 제거된다.
7. 그 아래에 있던 함수의 컨텍스트가 콜 스택의 맨 위로 오게 되면서 중단했던 코드의 다음 줄부터 다시 실행하게 된다.
8. 6-7번을 반복하다 전역 컨텍스트가 모두 실행되면, 전역 컨텍스트도 제거되고 콜 스택에는 아무것도 남지 않은 상태로 종료된다.

이 "컨텍스트에 관련된 코드들을 실행하는데 필요한 환경 정보"는 3가지이다.

* VariableEnvironment : 현재 컨텍스트 내의 식별자들에 대한 정보 + 외부 환경 정보 + 선언 시점의 LexicalEnvironment 스냅샷, 변경 사항은 반영되지 않음
* LexicalEnvironment : 처음에는 VariableEnvironment와 같지만 변경 사항이 실시간으로 반영됨
* ThisBinding : this 식별자가 바라봐야 할 대상 객체

## VariableEnvironment

LexicalEnvironment와 같지만 최초 실행 시의 스냅샷을 유지한다는 점이 다르다. 실행 컨텍스트를 생성할 때 (1)VariableEnvironment에 정보를 먼저 담은 다음, 이를 (2)그대로 복사해서 LexcialEnvironment를 만들고, 이후에는 (3)LexicalEnvironment만 활용한다.

VariableEnvironment와 LexicalEnvironment의 내부는 2가지로 구성되어 있다.

1. environmentRecord
2. outer-EnvironmentReference

## LexicalEnvironment

### environmentRecord와 호이스팅

현재 컨텍스트와 관련된 코드의 식별자 정보들이 저장된다. 

식별자란?

1. 컨텍스트를 구성하는 함수에 지정된 **매개변수 식별자**
2. 선언한 함수가 있을 경우 그 **함수 자체**
3. var로 선언된 **변수의 식별자**

컨텍스트 내부 전체를 처음부터 끝까지 쭉 훑어나가며 **<u>순서대로 수집</u>**한다.
이로써 자바스크립트 엔진은 코드가 실행되기도 전에 해당 환경에 속한 코드의 변수명을 모두 알고 있게 된다.

참고) 호스트 객체 : 전역 실행 컨텍스트는 변수 객체를 생성하는 대신 자바스크립트 구동 환경에서 제공하는 전역 객체를 활용한다. 브라우저의 `window` Node.js의 `global` 객체 등

#### 호이스팅이란?

environmentRecord의 수집 과정을 추상화한 것
var로 선언된 변수의 선언부를 가장 가까운 스코프의 가장 상단으로 끌어올리는 현상

#### 호이스팅 규칙

environmentRecord는 현재 실행될 컨텍스트의 대상 코드 내에 어떤 식별자들이 있는지에만 관심이 있고, 각 식별자에 어떤 값이 할당될 것인지는 관심이 없다. 따라서 변수를 호이스팅할 때 변수명만 끌어올리고 정의부분은 원래 있던 자리에 그대로 남겨둔다.

```js
function a() {
  console.log(b);
  var b = 'bbb';
  console.log(b);
  function b() { }
  console.log(b);
}
a(); 
// function b() {}
// 'bbb'
// 'bbb'
```

호이스팅에 의해 var변수 `b`와 함수 `b`의 선언부가 `a`함수의 가장 상단으로 올라간다. environmentRecord는 코드의 순서대로 수집되기 때문에 `a` 함수가 실행될 때 `b`의 초기값은 `function b() { }`가 된다. 그리고 3번째 줄에서 `b`에 값을 재정의하여 4,6번째 줄에는 `'bbb'`가 출력된다.

#### 함수 선언문과 함수 표현식

* 함수 선언문

  `function` 정의부만 존재하고, 별도의 할당 명령이 없는 것을 의미한다.
  반드시 함수명이 정의되어 있어야 한다.

* 함수 표현식

  정의한 `function`을 별도의 변수에 할당하는 것을 의미한다.
  함수명이 없어도 된다(있는 경우는 기명 함수 표현식, 없는 경우는 **익명 함수 표현식**)

함수 선언문을 사용할 경우 버그가 발생할 확률이 높아지므로 함수 표현식을 사용하자.
함수 표현식을 사용하게 되면, 호이스팅이 발생하긴하지만 함수가 정의되기 전에 함수를 호출하면 에러를 표출하고 같은 이름의 함수가 재정의되더라도 해당 정의된 코드 밑으로만 영향을 받게 된다. 하지만 가급적 같은 이름의 함수는 사용 자제...

### 스코프, 스코프 체인, outerEnvironmentReference

* 스코프(scope) : 식별자에 대한 유효범위

  어떤 경계 A의 외부에서 선언한 변수는 A의 외부뿐 아니라 A의 내부에서도 접근이 가능하지만,
  A의 내부에서 선언한 변수는 오직 A의 내부에서만 접근할 수 있다.

  ES5까지는 "함수에 의해서만" 스코프가 형성되었다.(if나 while같은 데에 변수 선언해도 가장 가까운 함수의 스코프에 속한다는 말인듯)
  ES6부터는 let, const 를 사용한 변수만 블록 스코프를 가지게 되었다.

* 스코프 체인(scope chain) : 식별자의 유효범위를 안에서부터 바깥으로 차례로 검색해나가는 것

* outerEnvironmentReference : 현재 호출된 함수가 선언될 당시의 LexicalEnvironment를 참조

  오직 자신이 선언된 시점의 L.E만 참조하고 있으므로 가장 가까운 요소부터 차례대로만 접근할 수 있다.

#### 스코프 체인

outerEnvironmentReference는 현재 호출된 **<u>함수가 선언될 당시</u>**의 LexicalEnvironment를 참조한다.
'선언하다'라는 생위가 실제로 일어날 수 있는 시점이란, 콜 스택 상에서 어떤 실행 컨테스트가 활성화된 상태일 뿐이다.

outerEnvironmentReference는 linked list 형태로 띄고 있고, 가장 마지막엔 전역 컨텍스트의 L.E가 있다. 구조적인 특성상 스코프 체인 상에 있는 변수라고 해서 무조건 접근 가능한 것은 아니고, 무조건 스포크 체인상에서 **가장 먼저 발견된 식별자에만 접근이 가능하다.**
변수 은닉화: 전역에 L.E와 outerEnvironmentReference에 동일한 이름의 변수가 있다면 outerEnvironmentReference에 있는 변수만 접근이 가능하다.

전역 L.E까지 살펴봤지만 변수가 없을 경우는 `undefined`를 반환한다.

#### 전역변수와 지역변수

전역변수 : 전역 스코프 내에서 선언한 변수들
지역 변수 : 함수 내부에서 선언한 변수들

## this

실행 컨텍스트의 thisBinding에는 this로 지정된 객체가 저장된다.
실행 컨텍스트 활성화 당시에 this가 지정되지 않는 경우 전역 객체가 저장된다.

# 