# Chapter1. 멀티스레딩
## 1.1 프로그램과 프로세스
#### 프로그램 
* 코드와 프로그램을 돌리는 데 필요한 데이터가 들어가 있는 "데이터 덩어리"
* 저장소에 존재 ex) 디스크
* 구성 요소 : 코드, 데이터
#### 프로세스
* 프로그램의 실행 상태
* RAM 메모리에 존재
* 구성 요소 : 코드, 데이터, **힙, 스택**
	* 스택 : 현재 실행 중인 **함수들의 호출 기**록과 **사용 중인 로컬 변수**들이 존재

### 멀티 프로세싱(multi processing)
>프로세스가 여러 개 실행되고 있는 것




## 1.2 스레드
* 명령어를 한 줄씩 실행하는 기본 단위
* 프로세스를 실행하면 기본적으로 "메인 스레드"가 동작한다.

### 스레드 vs 프로세스
| |스레드|프로세스|
|:---:|:---:|:---:|
|위치|프로세스 안에 여러 개 존재|OS 안에 여러 개 존재|
|단위 간 메모리 공간 공유|가능<br/>같은 프로세스의 다른 스레드간 데이터 공유|불가능<br/>프로세스간 데이터 공유 불가능|
|개별 스택|O|X|



#### Call Stack
>이 함수를 호출했던 지점에서 함수 안에 선언된 지역 변수, 그 코드의 위치 등을 저장
* 스레드마다 호출 스택을 각기 다르게 소유한다.
	* 왜?
	  스레드를 실행할 때 이 스레드가 최초로 실행될 "함수"도 호출하는데, 여기에 전달하는 인자 혹은 함수 자체가 모두 다르기 때문   
	  하지만 같은 함수, 같은 인자, 메모리 상태까지 모두 동일하더라도 실행 지점은 약간의 차이가 발생할 수 있다.


### 특징
* 스레드는 실행 순서대로 실행되지 않는다.
  -> 그래서 좀비 프로세스를 조심해야 한다.
* 모든 스레드가 종료되면 프로세스가 종료된다.
* 다른 스레드가 종료되기를 기다리며 "대기 상태"에 머무를 수 있다.

#### 좀비 프로세스
* 메인 스레드가 종료되었는데, 다른 스레드가 종료되지 않아서 프로세스가 종료되지 않는 현상
* 멀티 스레드 프로그램을 개발할 때 주의해야 한다.






## 1.3 멀티스레드 프로그래밍은 언제 해야 할까?
1. 오래 걸리는 일 하나와 빨리 끝나는 일 여럿을 같이 해야 할 때
   오래 걸리는 일 : 게임의 스테이지 안에 들어가기 위해서 그래픽 리소스(캐릭터, 배경 등)를 로딩하기 위해 많은 양의 데이터를 디스크에서 읽어오기
   빨리 끝나는 일 : 화면 렌더링
   -> 그래서 로딩하는 동안 로딩바나 미니 게임을 렌더링하여 사용자를 지루하지 않게 함
2. 어떤 긴 처리를 진행하는 동안 다른 짧은 일을 처리해야 할 때
   >게임 서버에서 플레이어 정보를 읽거나 쓰려고 디스크에 접근하는 경우
   
   디스크에 접근할 경우 스레드는 디스크의 처리가 끝날 때까지 기다린다 -> 이 시간동안 CPU가 논다
   -> 이 시간을 효율적으로 사용위해 멀티스레딩 or 비동기 프로그래밍
3. 기기에 있는 CPU를 모두 활용해야 할 때
   스레드를 사용하면 CPU의 모든 클럭을 사용할 수 있다.






## 1.4 스레드 정체
#### 컨텍스트 스위치
>스레드를 실행하다 말고 다른 세르드를 마저 실행하는 과정

* 운영체제는 여러 프로세스와 각 프로세스 안에 있는 스레드들을 일정 시간마다 번갈아가며 실행한다.
* 컨텍스트 스위칭의 단계
	1. 실행 중이던 스레드의 상태(호출 스택 등)를 어딘가에 저장
	2. 과거에 실행하다가 만 다른 스레드 중에서 하나를 고름
	3. 고른 스레드의 상태(호출 스택 등)를 복원
	4. 실행하던 지점으로 강제 이동
* 컨텍스트 스위칭이 너무 잦으면 오히려 비효율적이다.
* **타임 슬라이스** : 사람 입장에서 쾌적할 수 있는 가급적 긴 시간, 컨텍스트 스위칭을 위해 스레드 하나가 일시 정지했다 다시 시작하는 데까지 걸리는 시간
  약 5ms
#### 주의할 점
1. `cpu 개수` < `Runable 스레드 개수` 이면, 어느 CPU에선 반드시 컨텍스트 스위칭이 발생한다.
2. 컨텍스트 스위칭이 발생하는 타이밍은 제어할 수 없다.
명령어는 어셈블리 명령어 하나 단위로 이루어지는데, 어느 지점에서 컨텍스트 스위칭이 발생할 지 알 수 없다.
```
b = a * 2;
```

일 경우 어셈블리 코드는
```
r1 = a
r2 = r1 * 2
b = r2
```

이다.
이 3줄의 코드가 모두 실행된 후 컨텍스트 스위칭이 일어난다고 보장할 수 없다. 컨텍스트 스위칭은 `r1 = a`코드가 완료된 후에도 일어날 수 있다.






## 1.5 스레드를 다룰 때 주의사항
위 1.4의 주의할 점의 2번째 요건때문에, 스레드간 데이터 공유를 할 시 아래 경우가 발생할 수 있다.
1. 이미 변경된 데이터가 동기화되지 않아 이전 값을 덮어 쓰기
2. 이미 다른 스레드가 해제한 메모리에 또 다른 스레드가 접근


#### 원자성(atomicity)
한 스레드가 공유 자원을 접근했을 경우 다른 스레드는 접근하지 못하는 것

#### 일관성(consistency)
공유 자원이 일관성있는 상태를 유지하는 것





## 1.6 임계 영역과 뮤텍스
### Mutex(Mutual Exclusion, 상호 배제)
1. 공유 자원을 보호하는 뮤텍스 생성
2. 스레드는 공유 자원을 건드리기 전에 뮤텍스에게 "사용권을 얻겠다"고 요청
3. 스레드는 공유 자원에 접근
4. 접근이 끝나면 뮤텍스에게 "사용권을 놓겠다"고 요청

#### `lock_guard` 클래스
로컬 `lock_guard` 변수가 소멸될 때 뮤텍스를 자동으로 `unlock` 해주는 c++ 지원 클래스이다.
그래서 뮤텍스가 lock되었을 때 예외가 발생하더라도, 뮤텍스를 unlock해줄 수 있다.
[이게 어떻게 가능한걸까?](./chapter1-q1-how_lock_guard_works)


### Critical Section(임계 영억)
윈도우에서는 mutex보다 CriticalSection이 많이 사용된다.







