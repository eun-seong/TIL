---
title: Chap7. 유연한 함수를 만들어라
docType: book
---



가구 장인이 할인 판매점의 가구를 평가했다. 그는 목재의 마감이나 헐거운 나사 외에도 여러 가지 문제를 찾아냈다.   
목재를 자르기 전에 칠을 했을 뿐 아니라, 목재를 절단한 톱날이 무디다는 사실도 벗겨진 페인트 자국에서 알아냈다.
**벗겨진 페인트 흔적 하나가 장인에게 제조 공정과 사용 도구를 알려준 셈이다.** .  
**장인은 다른 사람이 보지 못하는 것을 볼 수 있다.**

## [32] 테스트하기 쉬운 함수를 작성하라 ⭐️

> 테스트 코드를 작성하면 좋은 점

- 리팩토링을 쉽게 할 수 있다.
- 오래된 코드를 훨씬 쉽게 이해할 수 있다.
- 일반적으로 더 명확하고 버그가 적은 앱을 만들 수 있다.


> 테스트 코드 작성이 어려워지기 위해선

- 함수에서 외부에 있는 함수를 호출한다.
- 외부 서비스나 설정 파일에 접근한다.
- 네트워크 통신을 한다.

> 이런 문제를 피하기 위해
1. 모의 객체(mock)를 생성해서
2. 함수를 가로채고
3. 명시적인 반환값을 설정한다.

예제에서는 `sinon` 라이브러리의 `stub`을 사용하고 있다.

테스트 코드가 긴 것은 문제이지만, 짧다고 해서 안전한 것은 아니다.   
테스트 코드에 spy, mock, stub 등 여러 외부 헬퍼를 사용하고 있다면, 코드가 복잡하고 강하게 결합되어 있다는 증거이다.
-> 이런 외부 함수를 인수로 전달하는 "의존성 주입"을 이용하여 문제를 해결할 수 있다.

* stub
  * 외부 코드를 덮어 써서 명시적인 결과를 반환하게 만든다.
  * 함수의 내부 논리를 모두 제거하고 결과만 선언한다.
* mock(모의 객체)
  * 원본 객체를 대체한다.
  * 원본 객체가 수신할 메세지와 호출할 메소드를 바탕으로 단언문을 작성한다.
  * stub과 다르게, 호출하기 전에 기댓값을 설정한다.
* spy
  * 코드를 실행한 후에 스파이가 어떻게 호출되었는지 확인한다.(횟수 등)


## [34] 부분 적용 함수로 단일 책임 매개변수를 관리하라 ⭐️⭐️
부분 적용 함수를 이용하면 한 번에 전달해야 할 함수 **인수의 수가 줄어**드는 대신,   
**인수를 더 전달해야 하는 다른 함수**를 반환한다.

전달 할 인수의 수를 줄여 함수를 나누면   
1. 독립적인 여러 매개변수 집합을 둘 수 있고
2. 매개변수가 단일 책임을 질 수 있다.
3. 나머지 매개변수(`...args`)를 재사용할 수 있다.
   ```ts
   hey(...arr1)(...arr2)
   ```


## [35] 커링과 배열 메소드를 조합한 부분 적용 함수를 사용하라 ⭐️⭐️⭐️

### 커링 함수 vs 부분 적용 함수
* 커링 함수
  * 정확히 인수 **하나**만 받는 **일련의 함수**를 반환할 때 사용한다.
* 부분 적용 함수
  * 원래 항수(함수가 받을 수 있는 전체 인수의 수)보다 항수가 적은 함수를 반환한다.


## [36] 화살표 함수로 문맥 혼동을 피하라
유효 범위는 -> 함수와 연관되어 있고,   
문맥은 -> 객체와 연관되어 있다.

> `undefined` 반환 & 타입 에러
```js
const validator = {
  message: '는 유효하지 않습니다.',
  setInvalidMessages(...fields) {
    return fields.map(function (field) {
      return `${field}${this.message}`;
    })
  }
}
```

> 화살표 함수 사용하면 문제 해결
```js
const validator = {
  message: '는 유효하지 않습니다.',
  setInvalidMessages(...fields) {
    return fields.map((field) => `${field}${this.message}`);
  }
}
```

함수가 호출될 때 `this 바인딩`을 하게 된다. 브라우저는 `window`, `Node.js`는 `global`이 될 것이다.
그래서 콜백 함수로 전달될 때 `this.message`에 접근할 수 없었던 것이다.

하지만 화살표 함수는 `this 바인딩`을 새로 하지 않는다. 
그래서 아래와 같이 프로퍼티에 함수를 할당하면 타입 에러가 발생한다.(this 바인딩을 생성하지 않아 전역 객체로 바인딩되기 때문에)
```js
const validator = {
  message: '는 유효하지 않습니다.',
  setInvalidMessages: (field) => `${field}${this.message}`
}
```


❓ this 바인딩은 함수를 "선언"할 때 발생하는 건가? "호출"할 때 발생하는건가?


* * *

### 글 찾아보기
* [테스트가 가능한 자바스크립트 코드 작성하기](https://www.toptal.com/javascript/writing-testable-code-in-javascript)
* [JS는 순수한 형태의 커링을 완벽하게 지원하지 않는다](https://2ality.com/2017/11/currying-in-js.html)
* [JS의 Scope와 Context 이해하기](http://ryanmorr.com/understanding-scope-and-context-in-javascript/)

